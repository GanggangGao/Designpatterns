# 设计模式


## 基本的UML类图的关系

	泛化关系（generalization）
		三角空心实线，泛化关系表现为继承非抽象类
		指向父类
		
	实现关系（realization）   
		三角空心虚线，实现关系表现为继承抽象类
		指向接口
		
	依赖关系（dependency）    
		箭头虚线   依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系处理临时知道对方，临时使用而并持有对方，这叫做依赖关系
		箭头指向被调用者，例如每个对象可以使用每个抽象功能，那么就指向这个抽象功能对象
		
	关联关系－单向关联（Directed Association） 
		箭头实线  例如A知道B而B不知道A，那么B就是A的关联对象，关联对象通常是以成员变量的形式实现的，持有对方
		指向被拥有者
		
	关联关系－双向关联（Association）
		实线  与单项关联不同的是：对象间相互知道 
		无指向
		
	聚合关系（Aggregation）   
		空心菱形实线 聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义
		
		空心菱形指向整体，实线箭头指向部分
		
		
	组合关系（Composition） 
		实心菱形实线  组合关系同样表示整体由部分构成的语义，但是它们是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了
		实心菱形指向整体，实线箭头指向成员变量
		
	泛化 = 实现 > 组合 > 聚合 > 关联 > 依赖 

## 设计模式之(命令模式）

### 基本概念

	1.将一个请求封装成为一个对象，从而让用户使用不同的请求将客户端参数化
	2.对请求排队或者纪录请求日志，以及支持撤销操作
	
### 角色划分

	接收者（负责具体的功能实现，执行具体的逻辑）   Receiver
	命令接口（命令抽象）                       Command
	具体的命令（调用接受者逻辑方法，行为方法）     ConcreteCommand
	请求者                                   Invoker
	
### UML类图

![](https://upload-images.jianshu.io/upload_images/7980283-34e35527b2d43bd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550)


### 应用场景

	当需要将方法调用包装成一个对象，以延时方法调用，或者让其他组件在对其内部实现细节不了解的情况下进行调用的时候可以使用命令模式
	场景一：应用程序支持撤销和恢复
	场景二：记录请求日志，当系统故障这些命令可以重新被执行
	场景三：想用对象参数化一个动作以执行操作，并且用不同命令对象来替换回调函数


### 命令模式的几种表现形式

	1.基本实现
		1)我有多少个命令，我就需要添加多少个命令文件
	2.DynamicCommand 动态添加命令
		1)只需要一个DynamicCommad的命令文件
		2)Manager管理对象的核心思想是performSelector:withObject:方法
		3)将我们所需要调用接受者的方法、参数以参数的形式给DynamicCommad
	3.复合命令
		1)也是单一的命令文件，与其他命令类对象只执行一次命令的结果不同的是，复合命令是执行的一连串的命令(数组)
		2)在执行的过程中，遍历所有数据，依次执行。
	4.GenericCommand 泛型命令	
		1)将命令对象参数以泛型的形式进行创建。
	5.闭包命令
		1)与上述几种不同变种来讲，这种更加简单
		2)在传统意义上的实现上，不再需要抽象命令、具体命令对象
		3)命令的参数需要在Manager中存储

		
## 设计模式之(适配器模式）

### 基本概念

	1.将一个原始接口转成客户端需要的接口
	2.原始接口不兼容现在新的接口，将他们两个可以一起工作

### 角色划分

	角色一：适配器（核心） Adapter
	角色二：目标接口      Target
	角色三：被适配者      Adaptee

### UML类图

![](https://upload-images.jianshu.io/upload_images/7980283-ebdc82e159ede422.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550)


### 应用场景

	1.接口不兼容
	2.可以重复使用的类，用于与一些彼此没有太大关联的一些类一起工作
	3.统一输出接口，输入端类型无法确定

### 适配器模式的几种表现形式
	
	1.对象适配器
		1)说白了就是在你的适配器中添加你的被适配者引用
		2)适合多个被适配者
	2.类适配器
		1)直接适配器继承被适配者
		2)适合那种单一被适配者


## 设计模式之(工厂模式：简单工厂、工厂方法、抽象工厂）

	工厂模式可以细分3个部分：简单工厂、工厂方法、抽象工厂这三种，而简单工厂又不属于GOF设计模式之一，下面就来简单介绍一下3中设计模式。


### 基本概念

	简单工厂模式
		1.简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例
		
	工厂方法模式
		1.定义一个创建对象的统一接口或基类：组件，然后由具体实现类或子类实现该接口
		2.该组件无需了解这些实现类的细节以及它们之间的关系
		
	抽象工厂模式
		1.为该组件提供一个创建一组相关联的对象
		2.无需知道创建对象所使用的类
		
### 角色划分

	简单工厂
		1.具体产品      ProductA ProductB ProductB  
		2.具体工厂      Factory   
		
	工厂方法
		1.抽象产品      ProductProtocol
		2.具体产品      ConcreteProductA  ConcreteProductB
		3.抽象工厂      FactoryProtocol
		4.具体工厂      ConcreteFactoryA  ConcreteFactoryB
	
	抽象工厂模式
		1.抽象产品      ProductProtocolA  ProductProtocolB
		2.具体产品 		 AConcreteProductA AConcreteProductB BConcreteProductA BConcreteProductB
		3.抽象工厂      FactoryProtocol
		4.具体工厂      ConcreteFactoryA  ConcreteFactoryA

### UML类图

#### 简单工厂
	
![简单工厂.png](https://upload-images.jianshu.io/upload_images/7980283-b4b38eae4f7116e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550)

#### 工厂方法模式

![工厂方法模式通用.png](https://upload-images.jianshu.io/upload_images/7980283-b9a2bf4d28baec89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/450)


#### 抽象工厂模式

![抽象工厂通用.png](https://upload-images.jianshu.io/upload_images/7980283-497ac520395a625f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550)


### 应用场景
	
	简单工厂
		该组件允许调用者根据特征来获取到相应的具体产品类，就可以使用该模式
	
	工厂方法
		当多个类共同实现同一或者继承同一基类的时候，就可以使用该模式
		
	抽象工厂
		如果调用组件需要创建多个相互协作的对象，且不需要知道这些对象之间有什么PY交易，那么就可以使用该模式
		

## 设计模式之(策略模式）

### 基本概念

	1. 定义了一系列的算法
	2. 每一种算法都是单独封装的
	3. 每一种算法都可以互相替换
	4. 调用者可以独立变化这些算法

### 角色划分

	1.策略接口
	2.具体策略
	3.策略的管理器
	
### UML类图

![策略模式.png](https://upload-images.jianshu.io/upload_images/7980283-431abee646d30f35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500)
	
	
### 应用场景
	
	1. 针对同一类型的问题多种处理方式，仅仅只是具体的行为有所差别
	2. 当你不需要修改原有类的情况下修改类的行为的时候，可以使用此模式
	3. 出现了同一抽象类有多个子类，而又需要使用if -- else 或者switch -- case的时候使用该模式

## 设计模式之(构建者模式）

### 基本概念
 
 	1. 使用构建者模式可以将创建对象的逻辑和默认配置放入到构建者类中
 	2. 调用者只需了解少量的配置参数就可以创建这个对象
 	3. 调用者无需了解也不需要知道创建对象的默认配置信息

### 角色划分

	1. 构造者 builder
	2. 具体产品 ConcreteProduct
	3. 参数类  parameters

### UML类图

![构建者模式.png](https://upload-images.jianshu.io/upload_images/7980283-3664382730997c19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550)

### 应用场景

	1. 当创建对象需要复杂的设置，而又不想让你的配置在整个应用程序中暴漏，那么请使用构建者模式
	2. 一般情况下该设计模式常常跟工厂方法、抽象工厂结合使用。


## 设计模式之(模版方法模式)

### 基本概念
	
	1. 定义一个操作中的算法框架
	2. 将一些步骤延时到子类实现
	3. 子类可以不改变算法结构，可以重新定义算法的某些特定步骤

### 角色划分

	1. Template         模版类
	2. ConreteTemplate  具体实现类

### UML类图

![模版方法模式.png](https://upload-images.jianshu.io/upload_images/7980283-2ae7c2ec85e03ecb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550)


### 应用场景

	1. 多个子类有公有方法，且逻辑基本相同
	2. 重复、复杂的算法，将核心算法设计为模版方法，其周边细节可以由子类去实现
	3. 代码重构


## 设计模式之(观察者模式)

### 基本概念

	一定一个对象间的一对多的依赖关系，当一个对象的状态发生该拜年时，所有依赖于它的对象都得到通知并被自动更新。
	
	
### 角色划分

	1. 被观察者(目标对象)
	2. 具体被观察者
	3. 观察者(抽象)
	4. 具体观察者   多个

### UML类图

![观察者模式.png](https://upload-images.jianshu.io/upload_images/7980283-b18fc1cca857c62b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550)


### 应用场景

	1. 对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象需要改变时
	2. 一个对象必须通知其他对象，而它并不知道其他对象具体是什么
	3. 两个抽象类型相互依赖，将它们分别封装到自己的对象中，就可以对它们单独进行改变


## 设计模式之(迭代器模式)

### 基本概念

	1. 迭代器提供了一种顺序访问聚合对象(集合)中元素的方法，而无需暴露结构的底层表示和细节。

### 角色划分

	1. 迭代器接口
	2. 具体迭代器
	3. 容器接口
	4. 具体容器

### UML类图

![迭代器模式.png](https://upload-images.jianshu.io/upload_images/7980283-3078a62962192456.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550)

### 应用场景

	1. 需要访问聚合或组合对象中的内容，而又不希望暴露其内部的表示。
	2. 需要通过多种方式遍历组合对象。
	3. 需要提供一个统一的接口，用来遍历各种类型的组合对象。

### 迭代器的变种
	
	1. 外部迭代器
		1）客户端需要知道外部迭代器才能使用，但它为客户端提供了更多的控制。
		2）客户端创建和维护外部迭代器
		3）客户端可以使用不同外部迭代器实现多种类型的遍历
	2. 内部迭代器
		1）客户端不需要知道任何外部迭代器，而是通过集合对象的融合接口，或者一次只访问一个元素，或者向每个元素发送消息。
		2）集合对象本身创建并维护它的外部迭代器
		3）集合对象可以在不修改客户端代码的情况下，选择不同的外部迭代器。
		
## 设计模式之(原型模式）

### 基本概念
	
	1. 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

### 角色划分

	1. 

